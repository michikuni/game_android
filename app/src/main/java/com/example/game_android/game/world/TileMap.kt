package com.example.game_android.game.world

import android.content.Context
import android.graphics.*
import com.example.game_android.game.core.Constants
import com.example.game_android.game.entities.PhysicsBody
import com.example.game_android.game.entities.Cloud
class TileMap(ctx: Context){ val cols=Constants.WORLD_COLS; val rows=Constants.WORLD_ROWS; val tile=Constants.TILE; val pixelWidth=(cols*tile).toFloat(); val pixelHeight=(rows*tile).toFloat(); val grid:Array<CharArray>; var playerStartX=tile*2; var playerStartY=tile*(rows-3); val spawnPoints=mutableListOf<Pair<Int,Int>>(); var bossStartX=tile*(cols-10); var bossStartY=tile*(rows-3)
    init{ grid=loadAsciiOrGenerate(ctx); scanSpecials() }
    private fun loadAsciiOrGenerate(ctx: Context): Array<CharArray>{ return try { ctx.assets.open("maps/level1.txt").bufferedReader().use{ br -> val lines=br.readLines().filter{it.isNotBlank()}; Array(rows){ r -> (if(r<lines.size) lines[r] else "").padEnd(cols,'.').toCharArray() } } } catch(_:Exception){ Array(rows){ CharArray(cols){'.'} }.also{ g-> val gy=rows-2; for(x in 0 until cols) g[gy][x]='#'; for(x in 0 until cols step 7) g[gy-1][x]='#'; for(x in 10 until cols-10 step 14){ val y=10+(x%3); for(i in 0..6) g[y][kotlin.math.min(cols-1,x+i)]='^' }; for(x in 50 until cols-20 step 25){ val y=6+(x%4); for(i in 0..10) g[y][kotlin.math.min(cols-1,x+i)]='^' }; g[gy-1][2]='P'; for(x in 40 until cols-60 step 80) g[gy-1][x]='E'; for(x in 120 until cols-60 step 100) g[gy-5][x]='E'; g[gy-1][cols-10]='B' } } }
    private fun scanSpecials(){ for(y in 0 until rows) for(x in 0 until cols){ when(grid[y][x]){ 'P'->{ playerStartX=x*tile; playerStartY=(y-1)*tile }; 'E'-> spawnPoints.add(x*tile to (y-1)*tile); 'B'->{ bossStartX=x*tile; bossStartY=(y-2)*tile } } } }
    fun isSolidAt(col:Int,row:Int)= row in 0 until rows && col in 0 until cols && grid[row][col]=='#'
    fun isOneWayAt(col:Int,row:Int)= row in 0 until rows && col in 0 until cols && grid[row][col]=='^'
    fun isSolidAtPx(px:Int,py:Int)= isSolidAt(px/tile, py/tile)
    fun moveAndCollide(e: PhysicsBody){ var nx=e.x+e.vx; val hb=RectF(nx,e.y,nx+e.w,e.y+e.h); if (collidesSolid(hb)){ if(e.vx>0) nx=((hb.right.toInt()/tile)*tile - e.w - 1).toFloat() else nx=((hb.left.toInt()/tile + 1)*tile).toFloat(); e.vx=0f }; e.x=nx; var ny=e.y+e.vy; val vb=RectF(e.x,ny,e.x+e.w,ny+e.h); val hitSolid=collidesSolid(vb); val hitOneWayDown=e.vy>=0 && collidesOneWayFromAbove(vb); if(hitSolid||hitOneWayDown){ if(e.vy>0){ ny=(vb.bottom - (vb.bottom % tile)).toInt().toFloat() - e.h - 0.1f; e.canJump=true } else if(e.vy<0 && hitSolid){ ny=(vb.top - (vb.top % tile) + tile).toInt().toFloat() }; e.vy=0f }; e.y=ny }
    private fun collidesSolid(r:RectF):Boolean{ val l=(r.left.toInt()/tile)-1; val t=(r.top.toInt()/tile)-1; val rr=(r.right.toInt()/tile)+1; val b=(r.bottom.toInt()/tile)+1; for(y in t..b) for(x in l..rr) if(isSolidAt(x,y)){ val rx=x*tile.toFloat(); val ry=y*tile.toFloat(); val cell=RectF(rx,ry,rx+tile,ry+tile); if(cell.left<r.right && cell.right>r.left && cell.top<r.bottom && cell.bottom>r.top) return true }; return false }
    private fun collidesOneWayFromAbove(r:RectF):Boolean{ val l=(r.left.toInt()/tile)-1; val t=(r.top.toInt()/tile)-1; val rr=(r.right.toInt()/tile)+1; val b=(r.bottom.toInt()/tile)+1; for(y in t..b) for(x in l..rr) if(isOneWayAt(x,y)){ val rx=x*tile.toFloat(); val ry=y*tile.toFloat(); val plat=RectF(rx,ry,rx+tile,ry+6f); if(r.bottom>plat.top && r.bottom<plat.bottom && r.right>plat.left && r.left<plat.right) return true }; return false }
    fun drawTiles(c:Canvas){ val p=Paint(); for(y in 0 until rows) for(x in 0 until cols){ when(grid[y][x]){ '#'->{ p.color=Color.rgb(80,82,100); c.drawRect((x*tile).toFloat(),(y*tile).toFloat(),((x+1)*tile).toFloat(),((y+1)*tile).toFloat(),p) }; '^'->{ p.color=Color.rgb(150,150,180); val top=RectF((x*tile).toFloat(),(y*tile).toFloat(),((x+1)*tile).toFloat(),(y*tile+6).toFloat()); c.drawRect(top,p) } } } }
    fun drawBackground(c:Canvas, cam: com.example.game_android.game.core.Camera, clouds: List<Cloud>){ val p=Paint(); p.color=Color.rgb(19,22,34); c.drawRect(0f,0f,c.width.toFloat(),c.height*0.6f,p); clouds.forEach{ it.draw(c, cam) } }
}